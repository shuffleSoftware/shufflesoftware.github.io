<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Mindmap</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            /* Prevents body scrolling */
        }

        #svg-container {
            width: 900px;
            /* Fixed container width */
            height: 700px;
            /* Fixed container height */
            overflow: auto;
            /* Enables scrolling when SVG exceeds container size */
            border: 1px solid #ccc;
            /* Optional: for visibility */
        }

        svg {
            display: block;
            /* Removes extra space below SVG */
        }

        #tooltip {
            position: absolute;
            background: white;
            border: 1px solid black;
            padding: 5px;
            display: none;
            /* Hidden by default */
        }
    </style>
</head>

<body>
    <div id="btnContainer"></div>
    <div id="svg-container">
        <svg id="mindmap-svg"></svg>
    </div>
    <div id="tooltip"></div>
    <script>
        (() => {
            const mindmapData = {
                name: "Amazon EKS",
                description: "A managed Kubernetes service provided by AWS, simplifying the deployment, management, and scaling of containerized applications using Kubernetes.",
                children: [
                    {
                        name: "Cluster Architecture",
                        description: "The structural components of an Amazon EKS cluster, including the managed control plane and worker nodes.",
                        children: [
                            {
                                name: "Control Plane",
                                description: "Managed by AWS, consists of the Kubernetes API server, scheduler, controller manager, and etcd."
                            },
                            {
                                name: "Worker Nodes",
                                description: "Compute resources where application workloads run, can be EC2 instances or Fargate."
                            }
                        ]
                    },
                    {
                        name: "Workload Management",
                        description: "Tools and resources for deploying and managing applications on Amazon EKS.",
                        children: [
                            {
                                name: "Pods",
                                description: "The smallest deployable units in Kubernetes, containing one or more containers."
                            },
                            {
                                name: "Deployments",
                                description: "Manage the deployment and scaling of a set of pods."
                            },
                            {
                                name: "StatefulSets",
                                description: "Manage stateful applications with persistent identities and storage."
                            },
                            {
                                name: "DaemonSets",
                                description: "Ensure a pod runs on every node, typically for logging or monitoring."
                            },
                            {
                                name: "Jobs",
                                description: "Manage one-off tasks that run to completion."
                            },
                            {
                                name: "CronJobs",
                                description: "Schedule jobs to run at specific times or intervals."
                            }
                        ]
                    },
                    {
                        name: "Networking",
                        description: "Components for managing communication between pods and external services.",
                        children: [
                            {
                                name: "Services",
                                description: "Expose pods internally or externally with types like ClusterIP, NodePort, LoadBalancer."
                            },
                            {
                                name: "Ingress",
                                description: "Manage external HTTP/HTTPS traffic to services."
                            },
                            {
                                name: "Network Policies",
                                description: "Define rules for pod-to-pod communication."
                            }
                        ]
                    },
                    {
                        name: "Storage",
                        description: "Solutions for persistent data storage in Amazon EKS.",
                        children: [
                            {
                                name: "Volumes",
                                description: "Temporary or persistent storage attached to pods."
                            },
                            {
                                name: "PersistentVolumes",
                                description: "Cluster-wide storage resources."
                            },
                            {
                                name: "PersistentVolumeClaims",
                                description: "Requests for storage by users."
                            },
                            {
                                name: "StorageClasses",
                                description: "Templates for dynamically provisioning storage."
                            }
                        ]
                    },
                    {
                        name: "Configuration & Secrets",
                        description: "Manage application configuration and sensitive data.",
                        children: [
                            {
                                name: "ConfigMaps",
                                description: "Store non-sensitive configuration data."
                            },
                            {
                                name: "Secrets",
                                description: "Store sensitive data securely."
                            }
                        ]
                    },
                    {
                        name: "Security",
                        description: "Features for securing Amazon EKS clusters and workloads.",
                        children: [
                            {
                                name: "IAM Roles for Service Accounts",
                                description: "Grant AWS permissions to pods."
                            },
                            {
                                name: "RBAC",
                                description: "Role-Based Access Control for managing permissions within the cluster."
                            }
                        ]
                    },
                    {
                        name: "AWS Integrations",
                        description: "Seamless integration with other AWS services.",
                        children: [
                            {
                                name: "Elastic Load Balancing",
                                description: "Distribute traffic to applications."
                            },
                            {
                                name: "IAM",
                                description: "Manage access and permissions."
                            },
                            {
                                name: "CloudWatch",
                                description: "Monitor and log cluster activities."
                            },
                            {
                                name: "VPC",
                                description: "Isolate and secure network resources."
                            },
                            {
                                name: "ECR",
                                description: "Store and manage container images."
                            }
                        ]
                    },
                    {
                        name: "Deployment Options",
                        description: "Different ways to deploy and manage Amazon EKS clusters.",
                        children: [
                            {
                                name: "EKS on EC2",
                                description: "User-managed worker nodes on EC2 instances."
                            },
                            {
                                name: "EKS on Fargate",
                                description: "Serverless compute for pods without managing servers."
                            },
                            {
                                name: "EKS Anywhere",
                                description: "Run EKS on-premises or in other clouds."
                            }
                        ]
                    },
                    {
                        name: "Add-ons",
                        description: "Optional components to enhance cluster functionality.",
                        children: [
                            {
                                name: "VPC CNI",
                                description: "Manage pod networking."
                            },
                            {
                                name: "CoreDNS",
                                description: "Provide DNS services within the cluster."
                            },
                            {
                                name: "Kube-proxy",
                                description: "Enable service networking."
                            },
                            {
                                name: "CSI Drivers",
                                description: "Integrate with AWS storage services."
                            }
                        ]
                    }
                ]
            };

            // Functions to manage local storage
            function getClickedNodes() {
                const clicked = localStorage.getItem('clickedNodes');
                return clicked ? JSON.parse(clicked) : []; // Return empty array if no data
            }

            function setClickedNodes(clickedNodes) {
                localStorage.setItem('clickedNodes', JSON.stringify(clickedNodes));
            }
            function getClickedNodes() {
                const clicked = localStorage.getItem('clickedNodes');
                return clicked ? JSON.parse(clicked) : []; // Return empty array if no data
            }

            function setClickedNodes(clickedNodes) {
                localStorage.setItem('clickedNodes', JSON.stringify(clickedNodes));
            }
            // Get SVG and tooltip elements
            const svg = document.getElementById("mindmap-svg");
            const tooltip = document.getElementById("tooltip");

            // Initialize bounding box variables to calculate SVG size
            let minX = Infinity;
            let maxX = -Infinity;
            let minY = Infinity;
            let maxY = -Infinity;

            // Function to create a node with hover functionality
            function createNode(x, y, name, description, color, radius = 20, image) {
                const group = document.createElementNS("http://www.w3.org/2000/svg", "g");
                group.addEventListener("click", () => {
                    let updatedClickedNodes = getClickedNodes();
                    if (!updatedClickedNodes.includes(name)) {
                        updatedClickedNodes.push(name); // Add to clicked list
                        setClickedNodes(updatedClickedNodes); // Update local storage
                    }
                    text.setAttribute("text-decoration", "line-through"); // Update UI
                    if (image) {
                        window.open(`assets/${image}`, "_blank");
                    }
                });
                // Create circle
                const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                circle.setAttribute("cx", x);
                circle.setAttribute("cy", y);
                circle.setAttribute("r", radius);
                circle.setAttribute("fill", color);
                group.appendChild(circle);

                // Create text
                const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
                text.setAttribute("x", x);
                text.setAttribute("y", y);
                text.setAttribute("text-anchor", "middle");
                text.setAttribute("dy", "0.3em");
                text.textContent = name;
                group.appendChild(text);

                // Check if this node was previously clicked
                const clickedNodes = getClickedNodes();
                if (clickedNodes.includes(name)) {
                    text.setAttribute("text-decoration", "line-through");
                }

                // Append group to SVG
                svg.appendChild(group);

                // Update bounding box using the group's bounding box
                const bbox = group.getBBox();
                minX = Math.min(minX, bbox.x);
                maxX = Math.max(maxX, bbox.x + bbox.width);
                minY = Math.min(minY, bbox.y);
                maxY = Math.max(maxY, bbox.y + bbox.height);

                // Add hover events for tooltip
                group.addEventListener("mouseover", (event) => {
                    tooltip.textContent = description;
                    tooltip.style.left = `${event.pageX + 10}px`;
                    tooltip.style.top = `${event.pageY + 10}px`;
                    tooltip.style.display = "block";
                });
                group.addEventListener("mouseout", () => {
                    tooltip.style.display = "none";
                });


                return group;
            }

            // Define center of the mindmap
            const centerX = 450; // Adjusted to center within potential SVG size
            const centerY = 350;

            // Create central node
            const centralNode = createNode(centerX, centerY, mindmapData.name, mindmapData.description, "lightblue", 30, mindmapData.image);

            // Calculate angles for main branches
            const mainBranches = mindmapData.children || [];
            const numMainBranches = mainBranches.length;
            const angleIncrement = numMainBranches > 0 ? 360 / numMainBranches : 0;

            // Create main branches and sub-branches
            mainBranches.forEach((branch, index) => {
                const angleDeg = index * angleIncrement;
                const angleRad = (angleDeg * Math.PI) / 180;
                const mainDistance = 200; // Distance from center to main branches
                const x = centerX + mainDistance * Math.cos(angleRad);
                const y = centerY + mainDistance * Math.sin(angleRad);

                // Draw line to main branch
                const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
                line.setAttribute("x1", centerX);
                line.setAttribute("y1", centerY);
                line.setAttribute("x2", x);
                line.setAttribute("y2", y);
                line.setAttribute("stroke", "black");
                svg.appendChild(line);

                // Update bounding box with line endpoints
                minX = Math.min(minX, centerX, x);
                maxX = Math.max(maxX, centerX, x);
                minY = Math.min(minY, centerY, y);
                maxY = Math.max(maxY, centerY, y);

                // Create main branch node
                const mainNode = createNode(x, y, branch.name, branch.description, "lightgreen", 20, branch.image);

                // Handle sub-branches
                const subBranches = branch.children || [];
                const numSubBranches = subBranches.length;
                if (numSubBranches > 0) {
                    const angleSpread = Math.min(60, 10 * numSubBranches);
                    const angleOffset = numSubBranches > 1 ? angleSpread / (numSubBranches - 1) : 0;

                    subBranches.forEach((subBranch, subIndex) => {
                        const subAngleDeg = angleDeg + (subIndex - (numSubBranches - 1) / 2) * angleOffset;
                        const subAngleRad = (subAngleDeg * Math.PI) / 180;
                        const subDistance = 350; // Distance from center to sub-branches
                        const subX = centerX + subDistance * Math.cos(subAngleRad);
                        const subY = centerY + subDistance * Math.sin(subAngleRad);

                        // Draw line to sub-branch
                        const subLine = document.createElementNS("http://www.w3.org/2000/svg", "line");
                        subLine.setAttribute("x1", x);
                        subLine.setAttribute("y1", y);
                        subLine.setAttribute("x2", subX);
                        subLine.setAttribute("y2", subY);
                        subLine.setAttribute("stroke", "black");
                        svg.appendChild(subLine);

                        // Update bounding box with sub-line endpoints
                        minX = Math.min(minX, x, subX);
                        maxX = Math.max(maxX, x, subX);
                        minY = Math.min(minY, y, subY);
                        maxY = Math.max(maxY, y, subY);

                        // Create sub-branch node
                        createNode(subX, subY, subBranch.name, subBranch.description, "lightyellow", 15, subBranch.image);
                    });
                }
            });

            // Set SVG size based on bounding box with a margin
            const margin = 50;
            const svgWidth = maxX - minX + 2 * margin;
            const svgHeight = maxY - minY + 2 * margin;
            svg.setAttribute("width", svgWidth);
            svg.setAttribute("height", svgHeight);
            svg.setAttribute("viewBox", `${minX - margin} ${minY - margin} ${svgWidth} ${svgHeight}`);
        })()
    </script>
</body>

</html>